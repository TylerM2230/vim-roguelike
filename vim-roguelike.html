<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vim Roguelike Practice</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        html, body {
            height: 100%; /* Ensure html and body take full height */
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent body scrollbars */
        }
        /* Apply the game font */
        body {
            font-family: 'Press Start 2P', cursive;
            overscroll-behavior: none; /* Prevent pull-to-refresh/scroll */
            background-color: #1a202c; /* Darker background for the whole page */
            color: #e2e8f0; /* Light text for body */
            display: flex; /* Use flex for main layout */
        }
        /* Main container for game and instructions - Expand to fill */
        .game-container {
            display: flex;
            flex-direction: row; /* Default side-by-side layout */
            gap: 1rem; /* Space between game and instructions */
            width: 100%;
            height: 100%; /* Fill body height */
            padding: 1rem; /* Padding inside the container */
            box-sizing: border-box; /* Include padding in dimensions */
            align-items: stretch; /* Make children stretch to equal height */
        }
        /* Instructions Panel - Slightly adjusted */
        .instructions-panel {
            background-color: #a0aec0; /* Lighter gray background */
            color: #2d3748; /* Dark text color */
            padding: 1rem;
            border: 4px solid #4a5568; /* Border */
            border-radius: 0.5rem; /* Rounded corners */
            font-size: 0.65rem; /* Keep font size reasonable */
            line-height: 1.3;
            width: 280px; /* Slightly wider for better readability */
            flex-shrink: 0; /* Prevent instructions from shrinking */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            overflow-y: auto; /* Add scroll if content overflows */
        }
        .instructions-panel h3 {
            font-size: 0.75rem;
            margin-bottom: 0.6rem;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            border-bottom: 2px solid #4a5568;
            padding-bottom: 0.4rem;
            flex-shrink: 0; /* Prevent header from scrolling */
        }
        .instructions-panel h4 {
             font-size: 0.7rem;
             margin-top: 0.6rem;
             margin-bottom: 0.2rem;
             font-weight: bold;
        }
         .instructions-panel ul { list-style: none; padding: 0; margin: 0; }
         .instructions-panel li { margin-bottom: 0.2rem; }
         .instructions-panel code {
             background-color: #cbd5e0;
             padding: 0.1em 0.3em;
             border-radius: 0.25rem;
             font-weight: bold;
             display: inline-block;
             min-width: 1.5em;
             text-align: center;
         }
         .status-bar {
             margin-top: auto; /* Push status bar to the bottom */
             padding-top: 0.8rem;
             text-align: center;
             font-weight: bold;
             border-top: 2px solid #4a5568;
             font-size: 0.7rem;
             flex-shrink: 0; /* Prevent status bar from scrolling */
         }
        /* Game screen area - Centers the <pre> tag */
        .game-screen-area {
            flex-grow: 1; /* Allow game screen to take up more space */
            display: flex;
            justify-content: center; /* Center <pre> horizontally */
            align-items: center;    /* Center <pre> vertically */
            flex-direction: column;
            overflow: hidden; /* Hide overflow for the area itself */
            height: 100%; /* Ensure it takes full height within container */
            box-sizing: border-box;
        }
        /* Ensure pre tag respects whitespace and line breaks */
        pre#game-display { /* Target specific pre tag */
            white-space: pre;
            font-family: monospace;
            line-height: 1.2; /* Adjusted line height for bigger font */
            font-size: 26px; /* Font size from previous step */
            overflow: auto; /* Add scrollbars *within* the pre if map exceeds area */
            background-color: #000000; /* Black background for contrast */
            color: #cccccc; /* Default light gray text */
            padding: 0.5rem; /* Adjust padding */
            border-radius: 0.5rem;
            border: 4px solid #666666; /* Medium gray border */
            box-sizing: border-box;
            display: inline-block; /* Needed for centering */
            max-width: 100%;
            max-height: 100%; /* Limit height to container */
        }

        /* --- Character Coloring --- */
        .player { color: #ffff00; font-weight: bold; } /* Bright Yellow */
        .goal   { color: #00ff00; font-weight: bold; } /* Bright Green */
        .trap   { color: #ff4444; font-weight: bold; } /* Bright Red */
        .wall   { color: #888888; } /* Medium Gray */
        .floor  { color: #444444; } /* Dark Gray */

         /* Message overlay style */
         #message-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.8); /* Darker overlay */
            color: white;
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 2rem; /* Even larger message text */
            padding: 2rem;
            z-index: 10;
         }
         #message-overlay button {
            margin-top: 1.5rem;
            padding: 0.75rem 1.5rem;
            background-color: #5a6578; /* Slightly lighter button */
            color: white;
            border: 2px solid #e2e8f0;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 1.25rem;
            font-family: 'Press Start 2P', cursive;
         }
         #message-overlay button:hover {
             background-color: #4a5568; /* Darker hover */
         }

         /* Responsive adjustments */
         @media (max-width: 768px) {
            body { overflow: auto; } /* Allow scrolling on small screens if needed */
            .game-container {
                flex-direction: column-reverse; /* Stack vertically, instructions on bottom */
                height: auto; /* Allow container to grow */
                min-height: 100vh; /* Ensure it still tries to fill height */
                padding: 0.5rem; /* Reduce padding */
                gap: 0.5rem;
            }
            .instructions-panel {
                width: 100%; /* Full width */
                max-height: 40vh; /* Limit height */
                font-size: 0.6rem; /* Smaller font on mobile */
            }
             .instructions-panel h3 { font-size: 0.7rem; }
             .instructions-panel h4 { font-size: 0.65rem; }
             .status-bar { font-size: 0.65rem; }

            .game-screen-area {
                width: 100%;
                min-height: 50vh; /* Ensure game area has decent height */
            }
             pre#game-display {
                 font-size: 18px; /* Adjust font size for mobile */
                 line-height: 1.15; /* Adjust line height for mobile */
                 padding: 0.25rem;
             }
         }

    </style>
</head>
<body>

    <div class="game-container">
        <div class="instructions-panel">
            <h3>-- Controls --</h3>
            <div>
                <h4>Movement</h4>
                <ul>
                    <li><code>h</code> : Left</li>
                    <li><code>j</code> : Down</li>
                    <li><code>k</code> : Up</li>
                    <li><code>l</code> : Right</li>
                </ul>
            </div>
             <div>
                <h4>Diagonals</h4>
                <ul>
                    <li><code>y</code> : Up-Left</li>
                    <li><code>u</code> : Up-Right</li>
                    <li><code>b</code> : Down-Left</li>
                    <li><code>n</code> : Down-Right</li>
                </ul>
            </div>
             <div>
                <h4>Jumps</h4>
                <ul>
                    <li><code>w</code> : Fwd 3</li>
                    <li><code>e</code> : Fwd 3</li>
                    <li><code>B</code> : Back 3</li>
                </ul>
            </div>
             <div>
                <h4>Objective</h4>
                <ul>
                    <li><span class="player">@</span> : You</li>
                    <li><span class="goal">&gt;</span> : Exit</li>
                    <li><span class="trap">X</span> : Trap</li>
                    <li><span class="wall">#</span> : Wall</li>
                     <li><span class="floor">.</span> : Floor</li>
                </ul>
            </div>
            <div class="status-bar">
                 <span id="level-display">Level: 1</span> | <span id="status-message"></span>
            </div>
        </div>

         <div class="game-screen-area">
            <pre id="game-display"></pre>
        </div>

    </div> <div id="message-overlay">
        <div id="message-content">
            <p id="message-text"></p>
            <button id="restart-button">Restart</button>
        </div>
    </div>

    <script>
        // --- Game Configuration ---
        const MAP_WIDTH = 36;
        const MAP_HEIGHT = 18;
        const PLAYER_CHAR = '@';
        const WALL_CHAR = '#';
        const FLOOR_CHAR = '.';
        const GOAL_CHAR = '>';
        const TRAP_CHAR = 'X';
        const JUMP_DISTANCE = 3;

        // --- Game State ---
        let player = { x: 1, y: 1 };
        let goal = { x: MAP_WIDTH - 2, y: MAP_HEIGHT - 2 };
        let gameMap = [];
        let gameActive = true;
        let currentLevel = 1;
        let traps = []; // Stores locations of placed traps {x, y}

        // --- DOM Elements ---
        const gameDisplay = document.getElementById('game-display');
        const statusMessage = document.getElementById('status-message');
        const levelDisplay = document.getElementById('level-display');
        const messageOverlay = document.getElementById('message-overlay');
        const messageText = document.getElementById('message-text');
        const restartButton = document.getElementById('restart-button');

        // --- Utility Functions ---
        function getRandomInt(max) { return Math.floor(Math.random() * max); }
        function shuffleArray(array) { /* Fisher-Yates shuffle */
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // --- Pathfinding Function (BFS) ---
        /**
         * Checks if a path exists between start and end coordinates on the map.
         * Treats WALL_CHAR as impassable.
         * @param {number} startX Starting X coordinate.
         * @param {number} startY Starting Y coordinate.
         * @param {number} endX Target X coordinate.
         * @param {number} endY Target Y coordinate.
         * @param {string[][]} mapToCheck The current state of the map to check.
         * @returns {boolean} True if a path exists, false otherwise.
         */
        function isPathAvailable(startX, startY, endX, endY, mapToCheck) {
            const queue = [{ x: startX, y: startY }];
            const visited = new Set([`${startX},${startY}`]); // Keep track of visited cells 'x,y'

            while (queue.length > 0) {
                const current = queue.shift(); // Get the next cell to visit

                // Check if we reached the goal
                if (current.x === endX && current.y === endY) {
                    return true; // Path found!
                }

                // Explore neighbors (up, down, left, right)
                const directions = [ { dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 } ];
                for (const dir of directions) {
                    const nextX = current.x + dir.dx;
                    const nextY = current.y + dir.dy;
                    const nextKey = `${nextX},${nextY}`;

                    // Check bounds
                    if (nextX >= 0 && nextX < MAP_WIDTH && nextY >= 0 && nextY < MAP_HEIGHT) {
                        // Check if the neighbor is not a wall and hasn't been visited
                        if (mapToCheck[nextY]?.[nextX] !== WALL_CHAR && !visited.has(nextKey)) {
                            visited.add(nextKey); // Mark as visited
                            queue.push({ x: nextX, y: nextY }); // Add to the queue to explore later
                        }
                    }
                }
            }

            return false; // Goal not reachable
        }


        // --- Map Generation (Randomized DFS) ---
        function generateMap() {
            // Initialize map, visited array, stack, and floorTiles list
            gameMap = Array.from({ length: MAP_HEIGHT }, () => Array(MAP_WIDTH).fill(WALL_CHAR));
            traps = []; // Clear traps for the new level
            const visited = Array.from({ length: MAP_HEIGHT }, () => Array(MAP_WIDTH).fill(false));
            const stack = [];
            const floorTiles = []; // Keep track of all reachable floor locations

            // Choose a random starting cell
            let startX = getRandomInt(Math.floor((MAP_WIDTH - 1) / 2)) * 2 + 1;
            let startY = getRandomInt(Math.floor((MAP_HEIGHT - 1) / 2)) * 2 + 1;
            player.x = startX; // Set player start position
            player.y = startY;
            stack.push({ x: startX, y: startY });
            visited[startY][startX] = true;
            gameMap[startY][startX] = FLOOR_CHAR;
            floorTiles.push({ x: startX, y: startY }); // Add start to floor tiles

            // Randomized Depth-First Search Algorithm (guarantees connectivity)
            while (stack.length > 0) { /* ... DFS maze carving logic ... */
                 const current = stack[stack.length - 1];
                 const neighbors = [];
                 const directions = [ { dx: 0, dy: -2 }, { dx: 0, dy: 2 }, { dx: -2, dy: 0 }, { dx: 2, dy: 0 } ];
                 shuffleArray(directions);
                 for (const dir of directions) {
                     const nx = current.x + dir.dx, ny = current.y + dir.dy;
                     if (nx > 0 && nx < MAP_WIDTH - 1 && ny > 0 && ny < MAP_HEIGHT - 1 && !visited[ny][nx]) {
                         neighbors.push({ x: nx, y: ny, wallX: current.x + dir.dx / 2, wallY: current.y + dir.dy / 2 });
                     }
                 }
                 if (neighbors.length > 0) {
                     const chosen = neighbors[0];
                     gameMap[chosen.wallY][chosen.wallX] = FLOOR_CHAR;
                     gameMap[chosen.y][chosen.x] = FLOOR_CHAR;
                     visited[chosen.y][chosen.x] = true;
                     stack.push({ x: chosen.x, y: chosen.y });
                     floorTiles.push({ x: chosen.x, y: chosen.y });
                     floorTiles.push({ x: chosen.wallX, y: chosen.wallY });
                 } else { stack.pop(); }
            } // --- End DFS ---


            // --- Place Goal '>' ---
            // Place goal on a reachable floor tile, ensuring path exists from start.
            let goalPlaced = false;
            shuffleArray(floorTiles);
            for (const tile of floorTiles) { /* ... Goal placement logic ... */
                 const dist = Math.abs(tile.x - player.x) + Math.abs(tile.y - player.y);
                 if (dist > Math.min(MAP_WIDTH, MAP_HEIGHT) / 1.5 && tile.x !== player.x && tile.y !== player.y) {
                      goal.x = tile.x; goal.y = tile.y; gameMap[goal.y][goal.x] = GOAL_CHAR; goalPlaced = true; break;
                 }
            }
            if (!goalPlaced) { /* ... Goal placement fallback ... */
                 for (const tile of floorTiles) {
                     if (tile.x !== player.x || tile.y !== player.y) {
                         goal.x = tile.x; goal.y = tile.y; gameMap[goal.y][goal.x] = GOAL_CHAR; goalPlaced = true; break;
                     }
                 }
            }
            if (!goalPlaced) { /* ... Final goal fallback ... */
                goal.x = MAP_WIDTH - 2; goal.y = MAP_HEIGHT - 2;
                if(gameMap[goal.y]?.[goal.x] !== undefined) {
                    if (gameMap[goal.y][goal.x] === WALL_CHAR) gameMap[goal.y][goal.x] = FLOOR_CHAR;
                    gameMap[goal.y][goal.x] = GOAL_CHAR;
                } else { console.error("Failed goal fallback."); }
            } // --- End Goal placement ---


            // --- Place Traps 'X' Safely ---
            const numTraps = Math.min(Math.floor(floorTiles.length / 20), 4 + currentLevel);
            let trapsPlaced = 0;
            shuffleArray(floorTiles); // Shuffle potential trap locations

            for (const tile of floorTiles) {
                if (trapsPlaced >= numTraps) break; // Stop if we've placed enough traps

                // Skip player start and goal locations
                if ((tile.x === player.x && tile.y === player.y) || (tile.x === goal.x && tile.y === goal.y)) {
                    continue;
                }

                // --- Connectivity Check ---
                // Temporarily mark the potential trap location as a wall
                const originalTile = gameMap[tile.y][tile.x]; // Should be FLOOR_CHAR
                gameMap[tile.y][tile.x] = WALL_CHAR;

                // Check if a path still exists from player start to goal
                const pathExists = isPathAvailable(player.x, player.y, goal.x, goal.y, gameMap);

                // Revert the temporary change
                gameMap[tile.y][tile.x] = originalTile;
                // --- End Connectivity Check ---


                // If placing the trap doesn't block the path, place it permanently
                if (pathExists) {
                    gameMap[tile.y][tile.x] = TRAP_CHAR; // Place the trap
                    traps.push({ x: tile.x, y: tile.y }); // Add to trap state array
                    trapsPlaced++;
                }
                 // If pathExists is false, we simply don't place the trap here and continue loop
            }
             // Note: It's possible fewer than numTraps might be placed if many locations block the path.
             // console.log(`Placed ${trapsPlaced} traps out of desired ${numTraps}.`); // Optional debug log

        } // --- End generateMap ---


        // --- Game Logic Functions ---
        function initializeLevel() { /* Initialize level state... */
            gameActive = true;
            generateMap(); // Includes safe trap placement now
            render();
            updateStatus(`Level ${currentLevel} Start!`);
            levelDisplay.textContent = `Level: ${currentLevel}`;
        }

        // Render the current game state to the display WITH COLORS
        function render() { /* ... Rendering logic (unchanged) ... */
            if (!gameDisplay) return;
            let displayHTML = "";
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    let char = ' '; let cssClass = '';
                    if (gameMap[y]?.[x] !== undefined) {
                         char = gameMap[y][x];
                        if (x === player.x && y === player.y) { char = PLAYER_CHAR; cssClass = 'player'; }
                        else if (x === goal.x && y === goal.y) { char = GOAL_CHAR; cssClass = 'goal'; }
                        else {
                            const isTrap = traps.some(t => t.x === x && t.y === y);
                            if (isTrap && char === TRAP_CHAR) { cssClass = 'trap'; }
                            else if (char === WALL_CHAR) { cssClass = 'wall'; }
                            else if (char === FLOOR_CHAR) { cssClass = 'floor'; }
                        }
                    }
                    if (cssClass) { displayHTML += `<span class="${cssClass}">${char}</span>`; }
                    else { displayHTML += char; }
                }
                displayHTML += "\n";
            }
            gameDisplay.innerHTML = displayHTML;
        }


        function showGameOverMessage(message) { /* Show game over overlay... */
            gameActive = false; messageText.textContent = message;
            messageOverlay.style.display = 'flex'; messageOverlay.style.backgroundColor = 'rgba(80, 0, 0, 0.8)';
        }
        function hideMessageAndRestart() { /* Hide overlay and restart... */
            messageOverlay.style.display = 'none'; currentLevel = 1; initializeLevel();
        }
        function updateStatus(message) { /* Update status message... */
            if (statusMessage) { statusMessage.textContent = message; }
        }
        function isValidMove(x, y) { /* Check move validity... */
            if (x < 0 || x >= MAP_WIDTH || y < 0 || y >= MAP_HEIGHT) { updateStatus("Out of bounds!"); return { valid: false }; }
            const targetCell = gameMap[y]?.[x];
            if (targetCell === undefined) { updateStatus("Invalid area!"); return { valid: false }; }
            if (targetCell === WALL_CHAR) { updateStatus("Bump! Wall."); return { valid: false }; }
            return { valid: true, target: targetCell, x: x, y: y };
        }
        function movePlayer(dx, dy) { /* Handle single step move... */
            if (!gameActive) return;
            const moveResult = isValidMove(player.x + dx, player.y + dy);
            if (moveResult.valid) { player.x = moveResult.x; player.y = moveResult.y; handleMoveConsequences(moveResult.target); }
            else { render(); }
        }
        function jumpPlayer(dx, dy, steps) { /* Handle multi-step jump... */
             if (!gameActive) return;
             let currentX = player.x, currentY = player.y, finalX = player.x, finalY = player.y, blocked = false;
             for (let i = 0; i < steps; i++) { /* Simulation loop... */
                 const nextX = currentX + dx, nextY = currentY + dy;
                 if (nextX < 0 || nextX >= MAP_WIDTH || nextY < 0 || nextY >= MAP_HEIGHT) { blocked = true; updateStatus("Jump bounds!"); break; }
                 if (gameMap[nextY]?.[nextX] === WALL_CHAR) { blocked = true; updateStatus("Jump blocked!"); break; }
                 currentX = nextX; currentY = nextY; finalX = nextX; finalY = nextY;
             }
             if (!blocked) { player.x = finalX; player.y = finalY; handleMoveConsequences(gameMap[player.y][player.x]); }
             else { render(); }
        }
        function handleMoveConsequences(targetCell) { /* Handle landing on a tile... */
             if (targetCell === GOAL_CHAR) { updateStatus(`Level ${currentLevel} Complete!`); currentLevel++; setTimeout(initializeLevel, 500); }
             else if (targetCell === TRAP_CHAR) {
                 gameMap[player.y][player.x] = FLOOR_CHAR; // Turn trap into floor
                 const trapIndex = traps.findIndex(t => t.x === player.x && t.y === player.y);
                 if (trapIndex !== -1) traps.splice(trapIndex, 1); // Remove trap state
                 showGameOverMessage(`Stepped on trap! Game Over (Lvl ${currentLevel})!`);
             } else { updateStatus(""); }
             render();
        }
        function handleKeydown(event) { /* Handle keyboard input... */
            if (!gameActive) return;
            if (['h', 'j', 'k', 'l', 'y', 'u', 'b', 'n', 'w', 'e', 'B'].includes(event.key)) { event.preventDefault(); }
            switch (event.key) { /* Key mapping... */
                case 'h': movePlayer(-1, 0); break; case 'j': movePlayer(0, 1); break;
                case 'k': movePlayer(0, -1); break; case 'l': movePlayer(1, 0); break;
                case 'y': movePlayer(-1, -1); break; case 'u': movePlayer(1, -1); break;
                case 'b': movePlayer(-1, 1); break; case 'n': movePlayer(1, 1); break;
                case 'w': case 'e': jumpPlayer(1, 0, JUMP_DISTANCE); break;
                case 'B': jumpPlayer(-1, 0, JUMP_DISTANCE); break;
            }
        }

        // --- Event Listeners ---
        document.addEventListener('keydown', handleKeydown);
        restartButton.addEventListener('click', hideMessageAndRestart);

        // --- Initial Game Start ---
        window.onload = function() { initializeLevel(); };

    </script>

</body>
</html>
